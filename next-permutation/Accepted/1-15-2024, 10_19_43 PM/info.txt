{"id":1147037295,"question_id":31,"lang":"cpp","lang_name":"C++","time":"5 months, 2 weeks","timestamp":1705337383,"status":10,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/1147037295/","is_pending":"Not Pending","title":"Next Permutation","memory":"12.5 MB","code":"\n\nclass Solution {\npublic:\n    void nextPermutation(std::vector<int>& nums) {\n        int n = nums.size();\n        int idx = -1;\n\n        // 1. Finding pivot\n        for (int i = n - 2; i >= 0; i--) {\n            if (nums[i] < nums[i + 1]) {\n                idx = i;\n                break;\n            }\n        }\n\n        // If array is greatest\n        if (idx == -1) {\n            reverse(nums.begin(), nums.end());\n            return;\n        }\n\n        // 2. Sorting/reverse after pivot\n        for (int i = idx + 1, j = n - 1; i < j; i++, j--) {\n            std::swap(nums[i], nums[j]);\n        }\n\n        // 3. Finding just greater index than pivot and swapping\n        auto it = upper_bound(nums.begin() + idx + 1, nums.end(), nums[idx]);\n        swap(nums[idx], *it);\n    }\n};\n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"next-permutation","has_notes":false,"flag_type":1}