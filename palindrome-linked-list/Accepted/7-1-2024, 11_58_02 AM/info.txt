{"id":1305513303,"question_id":234,"lang":"cpp","lang_name":"C++","time":"2Â days, 10Â hours","timestamp":1719815282,"status":10,"status_display":"Accepted","runtime":"143 ms","url":"/submissions/detail/1305513303/","is_pending":"Not Pending","title":"Palindrome Linked List","memory":"116.5 MB","code":"class Solution {\npublic:\n    ListNode* reverse(ListNode* head) {\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n        ListNode* Next = NULL;\n\n        while (curr) {\n            Next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = Next;\n        }\n        return prev;\n    }\n\n    bool isPalindrome(ListNode* head) {\n        if (!head || !head->next) // If the list is empty or has only one node\n            return true;\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n\n        // Find the middle of the linked list using fast and slow pointers\n        while (fast->next && fast->next->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        // Reverse the second half of the list starting from slow->next\n        ListNode* secondHalf = reverse(slow->next);\n        ListNode* firstHalf = head;\n\n        // Compare the first half and the reversed second half\n        while (secondHalf) {\n            if (firstHalf->val != secondHalf->val)\n                return false;\n            firstHalf = firstHalf->next;\n            secondHalf = secondHalf->next;\n        }\n\n        return true;\n    }\n};\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"palindrome-linked-list","has_notes":false,"flag_type":1}